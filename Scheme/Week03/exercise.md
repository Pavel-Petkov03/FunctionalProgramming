# Упражнение 3

![HOF Meme](../assets/03-hof.jpeg)

---
# Обясняванки

## Локални дефиниции (`let`, `let*`)
Конструкции, които ни позволяват да свържем име и стойност локално за израза.

- `let` прави паралелно (едновременно) свързване;
- `let*` прави последователно свързване, т.е. можем да ползваме по-горните дефиниции в тези след тях;
- `letrec` не го учим официално, но е супер готино и ни позволява да използваме дефинициите рекурсивно (но винаги мислим за дъно!)

```scheme
(define (sum-let a b)
  (let ([first  a]
        [second b])
    (+ first second)))

(define (division a b)
  (let* ([делимо  a]
         [делител b]
         [частно  (/ делимо делител)])
    частно))

(define (letrec-even? x)
  (letrec ([my-even?
              (lambda (x)
                (if (= x 0)
                    #t
                    (my-odd? (- x 1))))]
           [my-odd?
              (lambda (x)
                (not (my-even? x)))])
    (my-even? x)))
```

## Lambda функции

Анонимни фукнции - удобни когато фукнцията, която дефинираме, се използва само на едно място. Не е нужно да им измисляме име.

```scheme
(lambda (arg1 arg2 ... argn)
    body)

;; идентитет
(define id
  (lambda (a) a))

;; функция, която при подадено число, връща следващото
(define (++ a)
  (+ a 1))
;; всъщност е същото като
(define ++
  (lambda (a) (+ a 1)))

;; lambda функциите могат да бъдат извикани с аргументи веднага след дефиницията си
> ((lambda (x) (* x x)) 3) ;; => 9
```

## Функции от по-висок ред

Функциите в Scheme са "first-class citizens" - те могат да бъдат подавани наоколо, подобно на всички останали стойности (числа, списъци).

Функция от по-висок ред е тази, която приема функция като аргумент и/или връща функция като резултат.

```scheme
;; функция, която приема и връща функция като резултат
(define (apply2 func)
  (lambda (a b)
    (func a b)))

(apply2 + 1 2) ;; => error
;; apply2: arity mismatch;
;; the expected number of arguments does not match the given number
;; expected: 1
;; given: 3

((apply2 +) 1 2) ;; => 3
((apply2 expt) 2 3) ;; => 8
((apply2 string-append) "yo " "dawg") ;; => "yo dawg"
```

И, разбира се, познатият ни `accumulate` от лекции:

```scheme
(define (accumulate op nv a b term next)
  (if (> a b)
      nv
      (op (term a)
          (accumulate op nv (next a) b term next))))


(define (accumulate-i op nv a b term next)
  (if (> a b)
      nv
      (accumulate-i
        op
        (op nv (term a))
        (next a)
        b
        term
        next)))
```

# Задачи

#### Функции от по-висок ред
Дефинирайте следните функции с помощта на конструкцията `lambda`:
1. `(∘ f g)`, която връща композицията на `f` и `g`, т.е. `((∘ f g) x)` е
еквивалентно на `(f (g x))`
1. `(repeated n f x)`, която връща `f`, приложена `n` пъти върху `x`
1. `(repeat n f)`, която връща функция, чието действие има семантика на
прилагане на `f` `n` пъти

#### Accumulate

Напишете следните функции, използвайки `accumulate` или `accumulate-i`. Във всеки от случаите, нека `p` е произволна дадена функция (предикат), която връща `#t` или `#f` при подадено число:
1. `(count p a b)`, която връща брой числа `i` от интервала `[a, b]`, за които
`(p i) --> #t`
1. Предикат `(any? p a b)`, който проверява дали `p` връща истина за поне едно
цяло число от интервала `[a, b]`
1. Предикат `(all? p a b)`, който проверява дали `p` връща истина за всяко
цяло число от интервала `[a, b]`
1. Функциите `repeated` и `repeat` от предния раздел